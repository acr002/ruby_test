
hr = '-' * 36
a = 'if must S02.include?(1, 3, 8), unless must S01.include?(1), do S01.add(1)'
pat_a = /[^\(\)]+/
pat_b = /\([^\(\)]+\)/
pat_c = /[^\(\)]+$/
# pat   = /\([^\)]+(?=\([^\(\)]+\))|[^\(\)]+$/
pat   = /\([^\)]+(?=\([^\(\)]+\))/
pat_test_1 = /\(.*?\)|(,)/
pat_test_2 = /(?!\(\)),/
p = pat_test_2
b = a.scan(p)
p b
p p
puts b
p hr
p a.split(pat_test_1)

# \(.*?\)|(,)
# /(?!\()/
################################

# https://blog.pyq.jp/entry/Python_kaiketsu_200929
# まずはダブルコーテーションで括られたものを取り出す。
# 1. ダブルクォーテーションで囲まれた「ダブルクォーテーション以外の文字列」を探す
# 2. ダブルクォーテーションで囲まれた最小の文字列を探す
a = 'You say, "Yes, I am." and "No I am not.".'
pat1 = /"([^"]*)"[^"]*"([^"]*)"/
# pat1 = /"(A)"A"(A)"/
pat2 = /"(.*?)"[^"]*"(.*?)"/
pat1_1 = /"([^"]*)"/
pat2_1 = /"(.*?)"/
p a.scan(pat2_1)
################################

# https://abicky.net/2010/05/30/135112/
buf = 'hogefuga'
# pat = /.*(?=fuga)/
pat = /(.*)(?=fuga)(.*)/
a = buf.scan(pat)
p a
################################

# 肯定先読み: 対象(?=)
# 否定先読み: xxxx(?!先読み条件)

# 肯定後読み: (?<=)xxxx
# 否定後読み: (?<!後読み条件)xxxx
################################

buf = 'A.+(2.2).*(10).zero?'
# pat = /(.*)\(([^\)]+)\)/
# pat = /([^\(]+)\(([^\)]+)\)/
pat = /(?<=\().*?(?=\))/
pat = /(?<=\()[^\)]*/         # カッコの中に囲まれているもの
pat = /[^\(]+/
/.*?\(.*?\)/
/(?![^\(]+)\.(?<![^\)]+\))/
a = buf.scan(pat)
p a
################################

# a = 'You say, "Yes, I am.", "No, I am not.".'
a = 'You say.(Yes. I am.) . (No. I am not.).'
pat1 = /"([^"]*)"[^"]*"([^"]*)"/
# pat1 = /"(A)"A"(A)"/
pat2 = /"(.*?)"[^"]*"(.*?)"/
pat1_1 = /"([^"]*)"/
pat2_1 = /"(.*?)"/
# pat = /,(?=(?![^"]*"[^"]*")*[^"]*$)/
#     /,(?=(?:[^"]*"[^"]*")*[^"]*$)/
# pat = /,(?!([^"]"[^"]")*(?![^"]"))/       # 成功
# pat = /\.(?!([^"]*"[^"]")*(?![^"]"))/
pat = /(?=([^\(]\(\.[^\)]\))*(?![^\(]\())\./
pat = /(?<!\()*\./

# p a.scan(pat1_1)
# p a.scan(pat2_1)
# puts a.split(pat1_1)
# puts hr
# puts a.split(pat2_1)
# puts hr
puts a.split(pat)
################################

buf = 'https://instagram.com/p/hoge/masujirou'
a = buf.split('/')
p a
p a[-1]
*b, c = a
################################

# カッコで囲まれたドットは無視し、カッコで囲まれていないドットで区切る。
hr = '-' * 36
################################

a = []
a << 'ward'
a << 'wird'
a << 'wurd'
a << 'werd'
a << 'word'
a << 'test'
pat = /w[aeiou]rd/
a.each do |e|
  p pat.match(e)
end
################################

=begin
*       0回以上
+       1回以上
?       0..1回
{n}     ちょうどn回
{n,}    n回以上
{,n}    n回以下
{n,m}   n..m
=end
# 上記に?をつけることで最短の文字にマッチします。
=begin
*?      0回以上
+?      1回以上
??      0..1回
{n}?    ちょうどn回
{n,}?   n回以上
{,n}?   n回以下
{n,m}?  n..m
=end
text = 'Copyright 2021.'
p /^.*(\d+)\./.match(text)
p /^.*?(\d+)\./.match(text)

text = '<b>x</b>y<b>z</b>'
p %r(<b>(.*)</b>).match(text)
p %r(<b>(.*?)</b>).match(text)
################################

# C言語のコメント
%r(\/\*[^\*]*\*+(([^\*\/][^\*]*)\*+)*\/)
%r(ab[^b]*b+(([^ba][^b]*)b+)*a)










