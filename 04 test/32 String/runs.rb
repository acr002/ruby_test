
# 文字列の分解
# String#charsで一文字づつの配列にします。
# String#bytesで文字列を数値の配列にします。
# bytesの方が早くなりますが、業務等では可読性が落ちるのでcharsが選択肢になると思います。
a = '123abcABC'
cc = a.chars
bb = a.bytes
p cc, bb
################################

# charsなどは呼び出し時にはブロックを受け付けるので、eachを付けずに回すことができます。
# ただ、公式的には非推奨のようです。
a.chars do
  p _1
end
################################

# 変数に格納すると、Arrayになるので、eachが必要です。
p cc.class
cc.each do
  p _1
end
################################

# 文字列から文字をひとつずつ取り出すのであればeach_charを使います。
a = '123abcABC'
a.each_char do
  p _1
end
################################

p 'a'.ord
p 97.chr
################################

# 整数1つを受け取る(1行に1つ整数がある前提)
n = gets.to_s.to_i

# 1行を文字列として受け取る(chompで最後の改行を切り落としている)
s = gets.to_s.chomp

# 横1行のスペース区切りの整数を配列として受け取る
a = gets.to_s.split.map{ |e| e.to_i }

# n行1列の改行区切りの整数を配列として受け取る
a = Array.new(n){ gets.to_s.to_i }

# n行m列の整数を2次元配列で受け取る
m = Array.new(n){ gets.to_s.split.map{ |e| e.to_i } }
################################

# whileではなく、「while 修飾子」を使った例。
# すごい。
# 右辺の式を評価した値が真の間、左辺を繰り返し実行します。

# whileの右辺に破壊的メソッドを記述すればnilが返るまで実行します。
# 左辺の値が繰り返されますが、右辺の評価を繰り返すのが目的なので、左辺にはただのオブジェクトを置くようです。
s = '))(())('
1 while s.gsub!('()', '')
p s

# 下記でも同様です。
s = '))(())('
true while s.gsub!('()', '')
p s
################################





